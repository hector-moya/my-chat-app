import { CommonModule, NgFor } from '@angular/common';
import { ChangeDetectorRef, Component, EventEmitter, Input, OnInit, Output, inject } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { Channel } from 'src/app/interfaces/channel.model';
import { ChannelService } from 'src/app/services/channel.service';
import { PermissionService } from 'src/app/services/permission.service';
import { ModalComponent } from 'src/app/modal/modal.component';
import { ChannelManagementComponent } from './channel-management/channel-management.component';
import { UserService } from 'src/app/services/user.service';

@Component({
  standalone: true,
  selector: 'app-channel',
  templateUrl: './channel.component.html',
  styles: [
  ],
  imports: [NgFor, CommonModule, FormsModule, ModalComponent, ChannelManagementComponent]
})
export class ChannelComponent implements OnInit {
  @Input() groupId!: string;
  @Output() channelSelected = new EventEmitter<string>();
  user: any;
  channels: Channel[] = [];
  editingChannelId: string | null = null;
  showAddChannelModal: boolean = false;
  newChannelName: string = ''

  private channelService = inject(ChannelService);
  private changeDetectorRef = inject(ChangeDetectorRef);
  private userService = inject(UserService);
  public permissionService = inject(PermissionService);

  ngOnInit(): void {
    this.user = JSON.parse(localStorage.getItem('currentUser') || '{}');
    if (this.user) {
      if (this.user.status === 'super') {
        this.getAllChannels();
      } else {
        this.loadChannels();
      }
    }
  }

  loadChannels(): void {
    this.channelService.getUserChannel(this.groupId, this.user._id).subscribe({
      next: (channels) => {
        this.channels = channels;
        this.channels.forEach(channel => {
          this.checkCanEditChannel(channel);
        });
      },
      error: (err) => {
        console.log(err);
      },
    });
  }

  /**
   * Function to edit a channel
   * @param channelId
   */
  editingChannel(channelId: string): void {
    // Set the editingChannelId to the ID of the channel being edited
    this.editingChannelId = channelId;
  }

  /**
   * Function to save a channel
   * @param channel
   */
  saveChannel(channel: Channel): void {
    // Update the channel name and set the editing flag to false
    this.channelService.updateChannel(channel).subscribe((updatedChannel) => {
      channel.channelName = updatedChannel.channelName;
      this.editingChannelId = null;
    });
  }

  /**
   * Function to delete a channel
   * @param id
   */
  deleteChannel(_id: string): void {
    // Delete the channel using the ChannelService
    this.channelService.deleteChannel(_id).subscribe({
      next: () => {
        // Remove the channel from the array
        this.channels = this.channels.filter((g) => g._id !== _id);
        // Trigger change detection
        this.changeDetectorRef.detectChanges();
      },
      error: (error) => {
        console.error('Error deleting channel:', error);
      },
    });
  }

  /**
   * Function to check if the current user can edit a channel
   * @param channel
   */
  checkCanEditChannel(channel: Channel): void {
    if (channel._id) {
      this.userService.getUserRole(this.groupId, this.user._id).subscribe({
        next: (role) => {
          // Assume that if role name is 'admin' then the user can edit. Adjust this condition based on your roles.
          const canEdit = role.roleName === 'admin';
          this.permissionService.updateCanEditChannel(channel._id!, canEdit);
        },
        error: (err) => {
          console.error(`Error fetching role for channel ${channel._id}:`, err);
          this.permissionService.updateCanEditChannel(channel._id!, false);
        }
      });
    }
  }


  canEdit(channel: Channel): boolean {
    return channel._id? this.permissionService.canEditChannel[channel._id] || false : false;
  }


  openChat(channelId: string): void {
    this.channelSelected.emit(channelId);
  }


  getAllChannels(): void {
    this.channelService.getChannelsByGroupId(this.groupId).subscribe({
      next: (channels) => {
        this.channels = channels;
        // You can decide whether a superuser can edit all channels or not
        this.channels.forEach((channel) => {
          this.permissionService.updateCanEditChannel(channel._id!, true);
        });
      },
      error: (err) => {
        console.log(err);
      },
    });
  }

  
  // Function to show the add channel modal
  showModal(): void {
    this.showAddChannelModal = true;
  }

  // Function to add a new group
  addNewChannel(): void {
    if (this.newChannelName) {
      const newChannel: Channel = { channelName: this.newChannelName }; // id will be generated by the server
      this.channelService.addChannel(newChannel, this.groupId).subscribe({
        next: (channel) => {
          this.channels.push(channel); // Update the local channels array
          if (this.user.status === 'super' && channel._id) {
            this.permissionService.updateCanEditChannel(channel._id, true);
          } else {
            this.checkCanEditChannel(channel);
          }
          this.showAddChannelModal = false; // Hide the modal
          this.newChannelName = ''; // Clear the input
          this.changeDetectorRef.detectChanges(); // Trigger change detection
        },
        error: (error) => {
          console.log('Error adding new channel:', error);
        }
      });
    }
  }

}
