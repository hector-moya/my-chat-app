import { CommonModule, NgFor } from '@angular/common';
import { ChangeDetectorRef, Component, Input, OnInit } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { Channel } from 'src/app/models/channel.model';
import { ChannelService } from 'src/app/services/channel.service';
import { GroupComponent } from '../group/group.component';
import { PermissionService } from 'src/app/services/permission.service';

@Component({
  standalone: true,
  selector: 'app-channel',
  templateUrl: './channel.component.html',
  styles: [
  ],
  imports: [NgFor, CommonModule, FormsModule, GroupComponent]
})
export class ChannelComponent implements OnInit {
  @Input() groupId!: number;
  user: any;
  channels: Channel[] = [];
  editingChannelId: number | null = null;
  showAddChannelModal: boolean = false;
  newChannelName: string = ''

  constructor(private channelService: ChannelService, private changeDetectorRef: ChangeDetectorRef, public permissionService: PermissionService) { }
  ngOnInit(): void {
    this.user = JSON.parse(localStorage.getItem('currentUser') || '{}');
    if (this.user) {
      if (this.user.isSuper) {
        this.getAllChannels();
      } else {
        this.loadChannels();
      }
    }
  }

  loadChannels(): void {
    this.channelService.getUserChannel(this.groupId, this.user.id).subscribe({
      next: (channels) => {
        this.channels = channels;
      },
      error: (err) => {
        console.log(err);
      },
    });
  }

  /**
   * Function to edit a channel
   * @param channelId
   */
  editingChannel(channelId: number): void {
    // Set the editingChannelId to the ID of the channel being edited
    this.editingChannelId = channelId;
  }

  /**
   * Function to save a channel
   * @param channel
   */
  saveChannel(channel: Channel): void {
    // Update the channel name and set the editing flag to false
    this.channelService.updateChannel(channel).subscribe((updatedChannel) => {
      channel.channelName = updatedChannel.channelName;
      this.editingChannelId = null;
    });
  }

  /**
   * Function to delete a channel
   * @param id
   */
  deleteChannel(id: number): void {
    // Delete the channel using the ChannelService
    this.channelService.deleteChannel(id).subscribe({
      next: () => {
        // Remove the channel from the array
        this.channels = this.channels.filter((g) => g.id !== id);
        // Trigger change detection
        this.changeDetectorRef.detectChanges();
      },
      error: (error) => {
        console.error('Error deleting channel:', error);
      },
    });
  }


  canEdit(channelId: number): boolean {
    return this.permissionService.canEditChannel[channelId] || false;
  }


  openChat(id: number): void {
    console.log(`Here we will put the code to open the chat for channel: ${id}`);
  }


  getAllChannels(): void {
    this.channelService.getAllChannels().subscribe({
      next: (channels) => {
        this.channels = channels;
        // You can decide whether a superuser can edit all channels or not
        this.channels.forEach((channel) => {
          this.permissionService.updateCanEditChannel(channel.id, true);
        });
      },
      error: (err) => {
        console.log(err);
      },
    });
  }

  
  // Function to show the add group modal
  showModal(): void {
    console.log('Showing add group form');
    this.showAddChannelModal = true;
  }

  // Function to add a new group
  addNewChannel(): void {
    if (this.newChannelName) {
      const newChannel: Channel = { id: 0, channelName: this.newChannelName }; // id will be generated by the server
      this.channelService.addChannel(newChannel).subscribe({
        next: (channel) => {
          this.channels.push(channel); // Update the local groups array
          this.showAddChannelModal = false; // Hide the modal
          this.newChannelName = ''; // Clear the input
        },
        error: (error) => {
          console.log('Error adding new group:', error);
        }
      });
    }
  }

}
